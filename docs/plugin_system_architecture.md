# Plugin System Architecture

## Overview

Система плагинов предоставляет структурированный механизм обнаружения,
загрузки и управления жизненным циклом расширяемых компонентов.\
Все плагины обязаны наследоваться от `PluginBase` и управляются через
конечный автомат состояний (FSM).

Система ориентирована на:

- строгий контроль жизненного цикла,
- централизованное управление состоянием,
- явную модель ошибок,
- детерминированную загрузку.

---

# 1. Обнаружение и загрузка плагинов

## 1.1 Поиск модулей

`PluginFinder`:

- выполняет поиск файлов по заданному `pattern`,
- возвращает список модулей для загрузки.

На этапе поиска валидация содержимого не выполняется.

---

## 1.2 Импорт модулей

Каждый найденный модуль импортируется динамически.

Если импорт завершается ошибкой - процесс загрузки прерывается.

---

## 1.3 Извлечение класса плагина

`ClassExtractor`:

1. Извлекает атрибут `__plugin__` из модуля.
2. Проверяет:
   - что атрибут существует,
   - что это класс,
   - что класс наследуется от `PluginBase`.

При нарушении любого условия выбрасывается `PluginDefinitionError`.

---

## 1.4 Политика обработки ошибок загрузки

В текущей реализации:

- Невалидные модули **не игнорируются**.
- Любая ошибка импорта или извлечения класса:
  - прерывает загрузку,
  - приводит к `RuntimeError("Plugin loading failed")`.

Загрузка системы является атомарной - при ошибке она завершается полностью.

---

# 2. Контракт плагина

Все плагины обязаны наследоваться от:

```python
class PluginBase(ABC):
    def initialize(self) -> None: ...
    def start(self) -> None: ...
    def shutdown(self) -> None: ...
```

Плагин:

- не управляет своим состоянием напрямую,
- не должен вызывать lifecycle-методы самостоятельно,
- взаимодействует с системой только через менеджер.

---

# 3. Lifecycle и FSM

## 3.1 FSMAction → методы плагина

| FSMAction | Метод плагина |
|-----------|---------------|
| INIT      | initialize()  |
| START     | start()       |
| STOP      | shutdown()    |

Соответствие реализовано через `ACTION_TO_METHOD_MAP`.

---

## 3.2 Компоненты управления жизненным циклом

### PluginLifecycleController

Отвечает за:

- выбор допустимого перехода,
- делегирование выполнения `LifecycleTransitions`.

Контроллер не перехватывает исключения lifecycle-методов.

---

### LifecycleTransitions

Отвечает за:

- вызов соответствующего метода плагина,
- изменение состояния через `_apply_info`,
- перевод плагина в `FAILED` при ошибке,
- логирование исключения,
- повторный выброс исключения.

---

# 4. Модель состояния

Состояние плагина:

- хранится внутри объекта плагина (`_info`),
- изменяется только через `_apply_info`,
- обновляется исключительно в `LifecycleTransitions`.

Плагин не выполняет переходы состояния самостоятельно.

---

# 5. Failure Model

## 5.1 Ошибки lifecycle-методов

Если в `initialize()`, `start()` или `shutdown()` возникает исключение:

1. Плагин переводится в состояние `FAILED`.
2. Исключение логируется.
3. Исключение повторно пробрасывается вверх.

---

## 5.2 Ошибки вне lifecycle

Ошибки:

- при импорте модуля,
- при извлечении `__plugin__`,
- в конструкторе плагина,

---

# 6. Архитектурные инварианты

1. Lifecycle-методы вызываются только через FSM.
2. Переход состояния выполняется только через `LifecycleTransitions`.
3. Ошибка lifecycle-метода переводит плагин в `FAILED`.

---

# 7. Архитектурная модель

Система строится по следующей цепочке:

    PluginFinder
        ↓
    Import module
        ↓
    ClassExtractor (__plugin__)
        ↓
    Plugin instance creation
        ↓
    PluginLifecycleController
        ↓
    LifecycleTransitions
        ↓
    FSM + state mutation

---