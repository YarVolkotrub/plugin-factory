# Архитектура системы плагинов

Данный документ описывает архитектуру системы плагинов, их контракт, жизненный цикл и требования к реализации. Он предназначен для разработчиков, создающих плагины, а также для тех, кто расширяет или сопровождает ядро системы.

---

## Общая концепция

Система плагинов предоставляет **структурированный и предсказуемый подход** к созданию расширяемых компонентов с чётко определённым жизненным циклом.

Ключевые принципы:

* единый контракт плагина;
* централизованное управление состояниями;
* формализованная машина состояний (state machine);
* изоляция плагинов от runtime‑логики.

Все плагины:

* наследуются от базового абстрактного класса;
* управляются через менеджер жизненного цикла;
* взаимодействуют с системой только через определённые действия и состояния.

---

### Plugin API Invariants
1. Plugin должен наследоваться от `PluginBase`
2. Plugin **обязан быть объявлен в модуле через `__plugin__`**
2. Plugin должен содержать поле `NAME: str`
3. Поле `DESCRIPTION: str` является опциональным
3. Plugin должен реализовать все методы жизненного цикла
4. Plugin не должен управлять состоянием
5. Plugin не должен молча обрабатывать исключения жизненного цикла
6. Plugin должен обрабатывать `PluginMetadata` в режиме read-only

### Plugin Module Invariants

1. Каждый модуль плагина **обязан явно объявлять entrypoint** через атрибут `__plugin__`.
2. `__plugin__` должен ссылаться **ровно на один класс плагина**, определённый в данном модуле.
3. Класс, указанный в `__plugin__`:
   * обязан наследоваться от `PluginBase`;
   * не должен быть абстрактным;
   * должен быть определён в этом же модуле.
4. Модули, не содержащие `__plugin__`, считаются **невалидными и не загружаются**.
5. Автоматический поиск классов плагинов по namespace **не используется**.

### FSM Invariants
1. `FSM_TRANSITIONS` является единственным источником перехода между состояниями
2. Изменение состояний вне FSM не допускаются
3. Каждое действие `FSMAction` должно сопровождаться переходами состояний
4. Неверные переходы должны вызывать ошибку

### Architectural Invariants
1. Состояние плагина принадлежит исключительно фреймворку
2. Жизненный цикл плагина определяется исключительно FSM
3. `PluginMetadata` является неизменяемым
4. Все переходы между состояниями должны быть валидными
5. Любая ошибка в плагине приводит в состояние FAILED
6. Методы плагинов могут вызываться только через `PluginLifecycleController`
7. Любое отклонение от `FSM_TRANSITIONS` считается ошибкой архитектуры

### Failure Model
1. Плагин вызывает исключение
2. `PluginLifecycleController` перехватывает исключение
3. Ошибка сохраняется в `PluginMetadata`
4. FSM применяется для перехода в состояние FAILED

---

## Базовые сущности плагина

### PluginBase (ABC)

Абстрактный базовый класс, **обязательный для наследования всеми плагинами**. Определяет минимальный контракт и набор методов, которые должен реализовать каждый плагин.

Назначение:

* зафиксировать обязательный интерфейс плагина;
* обеспечить совместимость с lifecycle-менеджером;
* предотвратить использование некорректных плагинов.

Расположение:

* `src/plugin_factory/core/plugins/plugin_base.py`

---

### PluginMetadata (dataclass)

`PluginMetadata` - dataclass для хранения **метаинформации о плагине**.

Содержит, например:

* имя плагина (обязательно);
* описание;
* первоначальное состояние (выставляется автоматически при создание экземпляра)
* ошибка (заполняется при возникновении ошибки в ходе эксплуатации)
* дополнительные атрибуты, расширяемые в будущем.

Требования:

* метаинформация должна быть **доступна только на чтение**;
* допускается расширение структуры, но не изменение существующих полей.

Расположение:

* `src/plugin_factory/core/plugins/plugin_metadata.py`

---

### PluginMethod (StrEnum)

Перечень методов, которые **обязаны быть реализованы в плагине**.

Назначение:

* формализовать контракт на уровне перечислений;
* обеспечить соответствие между abstract-методами `PluginBase` и реальной реализацией плагина;
* использоваться при валидации плагинов.

Важно:

* список методов **должен строго соответствовать** abstract-методам `PluginBase`.

Расположение:

* `src/plugin_factory/core/plugins/plugin_method.py`

---

## Управление жизненным циклом плагина

### PluginLifecycleController

`PluginLifecycleController` - компонент, осуществляющий обращения к плагинам.

`PluginLifecycleController` является единственной точкой вызова методов плагинов.

Ответственность:

* применение действий пользователя к плагину;
* вызов FSM.

Инициализация:

* менеджер принимает таблицу переходов, реализующую `FSM_TRANSITIONS`;
* не содержит жёстко зашитой логики переходов.

Расположение:

* `src/plugin_factory/infrastructure/state_machine/lifecycle_controller.py`

---

### LifecycleTransitions

Компонент, инкапсулирующий логику переходов между состояниями.

Характеристики:

* создаётся и инициализируется внутри `PluginLifecycleController`;
* работает исключительно с `FSM_TRANSITIONS`;
* не содержит бизнес‑логики плагинов;
* перевод плагина в корректное состояние при ошибках;
* координация переходов между состояниями.

Расположение:

* `src/plugin_factory/infrastructure/state_machine/lifecycle_transitions.py`

---

## Машина состояний (State Machine)

### FSM_TRANSITIONS

Таблица переходов, определяющая:

* из какого состояния;
* при каком действии;
* в какое новое состояние

может быть переведён плагин.

Назначение:

* централизовать правила переходов;
* исключить невалидные сценарии использования;
* упростить расширение lifecycle.

Расположение:

* `src/plugin_factory/core/state_machine/fsm_transition.py`

---

### ACTION_TO_METHOD_MAP

Компонент сопоставления **действия → метода плагина**.

Используется для:

* ACTION_TO_METHOD_MAP - это неизменяемый инвариант, определяющий единственно допустимое сопоставление между FSMAction
  и методами плагина. Методы плагина не должны вызываться напрямую;
* определения, какой метод плагина вызывается при конкретном действии;
* проверки соответствия реализации плагина контракту.

Расположение:

* `src/plugin_factory/core/state_machine/action_to_method_map.py`

---

### FSMAction

Перечень допустимых действий, которые могут быть применены к плагину.

Примеры:

* инициализация;
* запуск;
* остановка.

Используется:

* lifecycle‑менеджером;
* таблицей переходов;

Расположение:

* `src/plugin_factory/core/state_machine/fsm_action.py`

---

### FSMState

Перечень возможных состояний плагина.

Назначение:

* формализация жизненного цикла;
* контроль допустимых переходов.

Расположение:

* `src/plugin_factory/core/state_machine/fsm_state.py`

---

## Требования к реализации плагинов

При разработке плагинов **обязательно** должны соблюдаться следующие требования:

1. **Наследование**

   * каждый плагин обязан наследоваться от `PluginBase`.

2. **Entrypoint**

   * каждый плагин обязан явно объявлять entrypoint:
     ```python
     __plugin__ = MyPlugin
     ```
   * отсутствие `__plugin__` считается ошибкой определения плагина.

3. **Соответствие методов**

   * abstract-методы `PluginBase` должны полностью совпадать с перечнем `PluginMethod`.

4. **Метаинформация**

   * метаданные плагина должны быть доступны через свойство `info` (существует в базовом классе);
   * у плагина должно быть заполнено поле `NAME: str`
   * `PluginMetadata` создается и обновляется исключительно архитектурным слоем. Плагины могут читать только `PluginMetadata`;
   * допускается только расширение.

5. **Обработка ошибок**

   * Любое необработанное исключение плагина перехватывается `PluginLifecycleController` и приводит к переходу в состояние FAILED.

6. **Переходы состояний**

   * все изменения состояния плагина обязаны соответствовать таблице переходов;
   * прямое изменение состояния запрещено.

---

## Границы ответственности

* Plugin:
  * реализует бизнес-логику
  * не управляет состоянием
  * не взаимодействует с FSM

* PluginLifecycleController:
  * вызывает методы плагина
  * перехватывает исключения
  * инициирует переходы состояний

* FSM:
  * валидирует переходы
  * не знает о runtime и исключениях

---

## Архитектурные гарантии

Соблюдение описанных принципов обеспечивает:

* предсказуемый жизненный цикл плагинов;
* безопасное расширение системы;
* изоляцию ошибок плагинов от ядра.
